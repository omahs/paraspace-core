// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import {IPool} from "../../interfaces/IPool.sol";
import {PToken} from "./PToken.sol";
import {WadRayMath} from "../libraries/math/WadRayMath.sol";
import {XTokenType} from "../../interfaces/IXTokenType.sol";
import {SafeCast} from "../../dependencies/openzeppelin/contracts/SafeCast.sol";
import {Errors} from "../libraries/helpers/Errors.sol";
import {IERC20} from "../../dependencies/openzeppelin/contracts/IERC20.sol";
import {GPv2SafeERC20} from "../../dependencies/gnosis/contracts/GPv2SafeERC20.sol";

/**
 * @title Rebasing PToken
 *
 * @notice Implementation of the interest bearing token for the ParaSpace protocol
 */
contract RebasingPToken is PToken {
    using WadRayMath for uint256;
    using SafeCast for uint256;
    using GPv2SafeERC20 for IERC20;

    constructor(IPool pool) PToken(pool) {
        //intentionally empty
    }

    /**
     * @dev Calculates the balance of the user: principal balance + interest generated by the principal
     * @param user The user whose balance is calculated
     * @return The balance of the user
     **/
    function balanceOf(address user) public view override returns (uint256) {
        return
            _scaledBalanceOf(user, lastRebasingIndex()).rayMul(
                POOL.getReserveNormalizedIncome(_underlyingAsset)
            );
    }

    /**
     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the
     * updated stored balance divided by the reserve's liquidity index at the moment of the update
     * @param user The user whose balance is calculated
     * @return The scaled balance of the user
     **/
    function scaledBalanceOf(address user)
        public
        view
        override
        returns (uint256)
    {
        return _scaledBalanceOf(user, lastRebasingIndex());
    }

    /**
     * @dev Returns the scaled balance of the user and the scaled total supply.
     * @param user The address of the user
     * @return The scaled balance of the user
     * @return The scaled balance and the scaled total supply
     **/
    function getScaledUserBalanceAndSupply(address user)
        external
        view
        override
        returns (uint256, uint256)
    {
        uint256 rebasingIndex = lastRebasingIndex();
        return (
            _scaledBalanceOf(user, rebasingIndex),
            _scaledTotalSupply(rebasingIndex)
        );
    }

    /**
     * @dev calculates the total supply of the specific aToken
     * since the balance of every single user increases over time, the total supply
     * does that too.
     * @return the current total supply
     **/
    function totalSupply() public view override returns (uint256) {
        uint256 currentSupplyScaled = _scaledTotalSupply(lastRebasingIndex());

        if (currentSupplyScaled == 0) {
            return 0;
        }

        return
            currentSupplyScaled.rayMul(
                POOL.getReserveNormalizedIncome(_underlyingAsset)
            );
    }

    /**
     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)
     * @return the scaled total supply
     **/
    function scaledTotalSupply()
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _scaledTotalSupply(lastRebasingIndex());
    }

    function _scaledBalanceOf(address user, uint256 rebasingIndex)
        internal
        view
        returns (uint256)
    {
        return super.scaledBalanceOf(user).rayMul(rebasingIndex);
    }

    function _scaledTotalSupply(uint256 rebasingIndex)
        internal
        view
        returns (uint256)
    {
        return super.scaledTotalSupply().rayMul(rebasingIndex);
    }

    /**
     * @return Current rebasing index in RAY
     **/
    function lastRebasingIndex() internal view virtual returns (uint256) {
        // returns 1 RAY by default which makes it identical to PToken in behaviour
        return WadRayMath.RAY;
    }

    function getXTokenType()
        external
        pure
        virtual
        override
        returns (XTokenType)
    {
        return XTokenType.RebasingPToken;
    }

    function mint(
        address caller,
        address onBehalfOf,
        uint256 amount,
        uint256 index
    ) external virtual override onlyPool returns (bool) {
        uint256 rebasingIndex = lastRebasingIndex();
        uint256 amountRebased = amount.rayDiv(rebasingIndex);
        return _mintScaled(caller, onBehalfOf, amountRebased, index);
    }

    function burn(
        address from,
        address receiverOfUnderlying,
        uint256 amount,
        uint256 index
    ) external virtual override onlyPool {
        uint256 rebasingIndex = lastRebasingIndex();
        uint256 amountRebased = amount.rayDiv(rebasingIndex);
        _burnScaled(from, receiverOfUnderlying, amountRebased, index);
        if (receiverOfUnderlying != address(this)) {
            IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);
        }
    }

    function mintToTreasury(uint256 amount, uint256 index)
        external
        virtual
        override
        onlyPool
    {
        if (amount == 0) {
            return;
        }
        uint256 rebasingIndex = lastRebasingIndex();
        uint256 amountRebased = amount.rayDiv(rebasingIndex);
        _mintScaled(address(POOL), _treasury, amountRebased, index);
    }

    function _transfer(
        address from,
        address to,
        uint256 amount,
        bool validate
    ) internal override {
        address underlyingAsset = _underlyingAsset;

        uint256 rebasingIndex = lastRebasingIndex();
        uint256 index = POOL.getReserveNormalizedIncome(underlyingAsset);

        uint256 fromBalanceBefore = _scaledBalanceOf(from, rebasingIndex)
            .rayMul(index);
        uint256 toBalanceBefore = _scaledBalanceOf(to, rebasingIndex).rayMul(
            index
        );

        _transferScaled(from, to, amount.rayDiv(rebasingIndex), index);

        if (validate) {
            POOL.finalizeTransfer(
                underlyingAsset,
                from,
                to,
                false,
                amount,
                fromBalanceBefore,
                toBalanceBefore
            );
        }
    }
}
